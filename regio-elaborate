#!/usr/bin/env python3

import click
from pathlib import Path
import sys

from yaml import load, dump
try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

from yamlinclude import YamlIncludeConstructor

name_escape = str.maketrans("~!@#$%^&*()-+=;,./?",
                            "___________________")

def elaborate_fields(flds_in, defaults):
    # Set up some default defaults in addition to the ones inherited from the containing register
    defaults.update({
        'init': 0,
    })

    fld_offset = 0
    flds = []
    synth_fld_cnt = 0
    for fld in flds_in:
        if 'default' in fld:
            defaults.update(fld['default'])
            continue
        
        # Set up a new field based on current context
        fnew = {}
        fnew.update(defaults)
        fnew.update({
            'offset': fld_offset,
        })

        if 'meta' in fld:
            meta = fld['meta']
            if 'pad_until' in meta:
                if fld_offset > meta['pad_until']:
                    # Negative padding!
                    print("Negative padding requested at offset", fld_offset)
                    sys.exit(1)
                elif fld_offset == meta['pad_until']:
                    # No padding required
                    print("Padding not required at offset", fld_offset)
                    sys.exit(1)
                else:
                    fnew.update({
                        'name':   "anon{:03d}".format(synth_fld_cnt),
                        'access': 'none',
                        'width':  (meta['pad_until'] - fld_offset)
                    })
                    synth_fld_cnt += 1
        else:
            fnew.update(fld)

        # Provide safe names
        safename = fnew['name'].translate(name_escape)
        fnew.update({
            'name':       safename,
            'name_lower': safename.lower(),
            'name_upper': safename.upper(),
        })

        # Compute the appropriate mask
        fnew.update({
            'mask':  ((1 << fnew['width']) - 1 << fld_offset)
        })

        flds.append(fnew)
        fld_offset += fnew['width']

    return flds, fld_offset

def elaborate_regs(regs_in):
    # Set up some default defaults
    defaults = {
        'count' : 1,
        'access' : 'ro',
        'init' : 0,
    }

    reg_offset = 0
    regs = []
    synth_reg_cnt = 0
    for reg in regs_in:
        if 'default' in reg:
            defaults.update(reg['default'])
            continue

        # Set up a new register based on current context
        rnew = {}
        rnew.update(defaults)
        rnew.update({
            'offset': reg_offset,
        })

        if 'meta' in reg:
            meta = reg['meta']
            if 'pad_until' in meta:
                if reg_offset > meta['pad_until']:
                    # Negative padding!
                    print("Negative padding requested at offset", reg_offset)
                    sys.exit(1)
                elif reg_offset == meta['pad_until']:
                    # No padding required
                    print("Padding not required at offset", reg_offset)
                    sys.exit(1)
                else:
                    rnew.update({
                        'name':   "anon{:03d}".format(synth_reg_cnt),
                        'access': 'none',
                        'width': 8,
                        'count':  (meta['pad_until'] - reg_offset)
                    })
                    synth_reg_cnt += 1
        else:
            # merge in the yaml register definition
            rnew.update(reg)
            if 'fields' in rnew:
                # Elaborate the fields
                field_defaults = {
                    'access': rnew['access']
                }
                rnew['fields'], rnew['computed_width'] = elaborate_fields(rnew['fields'], field_defaults)

        # Provide safe names
        safename = rnew['name'].translate(name_escape)
        rnew.update({
            'name':       safename.translate(name_escape),
            'name_lower': safename.lower(),
            'name_upper': safename.upper(),
        })

        regs.append(rnew)
        reg_offset += (rnew['width'] * rnew['count']) // 8

    return regs, reg_offset


def elaborate_block(blk):
    # Provide safe names
    safename = blk['name'].translate(name_escape)
    blk.update({
        'name':       safename,
        'name_lower': safename.lower(),
        'name_upper': safename.upper(),
    })

    # Elaborate the regs
    blk['regs'], blk['computed_size'] = elaborate_regs(blk['regs'])

def elaborate_crossbar(crossbar):
    # Elaborate any referenced child blocks
    if 'blocks' in crossbar:
        for _, blk in crossbar['blocks'].items():
            elaborate_block(blk)

    # Elaborate any referenced child crossbars
    if 'crossbars' in crossbar:
        for _, cbar in crossbar['crossbars'].items():
            elaborate_crossbar(cbar)

    # Provide safe names
    safename = crossbar['name'].translate(name_escape)
    crossbar.update({
        'name':       safename,
        'name_lower': safename.lower(),
        'name_upper': safename.upper(),
    })

    # TODO Check if any of the address ranges on any of the interfaces overlap
    # TODO Check if all of the address ranges fit within the address ranges of the master

    # Elaborate the region list from the interfaces defined in this crossbar
    crossbar['regions'] = []
    if 'interfaces' in crossbar:
        for i, intf in enumerate(crossbar['interfaces']):
            if not 'address' in intf:
                print("Crossbar {}: Missing 'address' definition".format(crossbar['name']))
                sys.exit(1)
            if not 'width' in intf:
                print("Crossbar {}: Missing 'intf' definition".format(crossbar['name']))
                sys.exit(1)

            intf_size_bytes = 2**intf['width']

            if 'crossbar' in intf:
                # bubble the regions upward, adding in this interface's offset
                for region in intf['crossbar']['regions']:
                    new_region = {
                        'offset' : intf['address'] + region['offset'],
                        'block'  : region['block'],
                        'size'   : region['size'],
                    }
                    if 'as' in region:
                        new_region.update({
                            'as'       : region['as'],
                            'as_lower' : region['as'].lower(),
                            'as_upper' : region['as'].upper(),
                        })
                    if 'suffix' in intf:
                        asname = new_region.get('as', new_region['block']['name']) + intf['suffix']
                        new_region.update({
                            'as'       : asname,
                            'as_lower' : asname.lower(),
                            'as_upper' : asname.upper(),
                        })
                    crossbar['regions'].append(new_region)
            elif 'block' in intf:
                blk = intf['block']
                if blk['computed_size'] > intf_size_bytes:
                    print("Crossbar {} interface {} block {} exceeds interface width".format(
                        crossbar['name'],
                        i,
                        blk['name']))
                    sys.exit(1)
                new_region = {
                    'offset' : intf['address'],
                    'block'  : intf['block'],
                    'size'   : intf_size_bytes,
                }
                if 'as' in intf:
                    new_region.update({
                        'as' : intf['as'],
                    })
                if 'suffix' in intf:
                    asname = new_region.get('as', new_region['block']['name']) + intf['suffix']
                    new_region.update({
                        'as'       : asname,
                        'as_lower' : asname.lower(),
                        'as_upper' : asname.upper(),
                    })
                crossbar['regions'].append(new_region)

    return

def elaborate_toplevel(top):
    PAGE_SIZE = 4096

    # Provide safe names
    safename = top['name'].translate(name_escape)
    top.update({
        'name':       safename,
        'name_lower': safename.lower(),
        'name_upper': safename.upper(),
    })

    # Elaborate the bars
    for barid, bar in top['bars'].items():
        # Provide safe names
        safename = bar['name'].translate(name_escape)
        bar.update({
            'name':       safename,
            'name_lower': safename.lower(),
            'name_upper': safename.upper(),
        })
        
        # Elaborate the crossbar
        crossbar = bar['crossbar']
        elaborate_crossbar(crossbar)

        # Insert padding between the regions
        padded_regions = []
        offset = 0
        synth_region_cnt = 0
        for region in sorted(crossbar['regions'], key=lambda r: r['offset']):
            # Check if we padding between regions
            if region['offset'] > offset:
                # Insert padding before region
                padded_regions.append({
                    'anon' : "anon{:03d}".format(synth_region_cnt),
                    'offset' : offset,
                    'count' : region['offset'] - offset,
                    'size' : region['offset'] - offset,
                })
                synth_region_cnt += 1
                offset = region['offset']
            elif region['offset'] < offset:
                # Overlapping regions
                print("Overlapping regions at offset", offset)
                print("  Previous region overlaps this region ({}) by {:d} bytes".format(
                    region['block']['name'],
                    region['offset'] - offset,))
                sys.exit(1)
            else:
                # Everything lines up perfectly
                pass

            # Insert the current block
            padded_regions.append(region)
            offset += region['block']['computed_size']

            # Check if we need any padding to fill up the region
            pad_size = region['size'] - region['block']['computed_size']
            if pad_size > 0:
                padded_regions.append({
                    'anon' : "anon{:03d}".format(synth_region_cnt),
                    'offset' : offset,
                    'count' : pad_size,
                    'size' : pad_size,
                })
                offset += pad_size
                synth_region_cnt += 1

        # Check if we need padding at the end
        if offset < bar['size']:
            # Insert padding to fill up the bar
            padded_regions.append({
                'anon' : "anon{:03d}".format(synth_region_cnt),
                'offset' : offset,
                'count' : bar['size'] - offset
            })
        elif offset > bar['size']:
            # Regions don't fit within the bar
            print("Regions exceed bar size by {} bytes".format(bar['size'] - offset))
            sys.exit(1)
        else:
            # Everything lines up perfectly
            pass

        bar['regions'] = padded_regions
        
        # Fill in the size in pages
        bar_size_pages = bar['size'] // PAGE_SIZE
        if bar['size'] % PAGE_SIZE > 0:
            bar_size_pages += 1
        bar['size_pages'] = bar_size_pages


@click.command()
@click.option('-i', '--include-dir',
              help="Include directory for block definitions",
              default=Path(__file__).parent.absolute().joinpath('blocks'),
              show_default=True,
              type=click.Path(exists=True, file_okay=False))
@click.option('-o', '--output-file',
              help="Output file for elaborated yaml file",
              default="-",
              show_default=True,
              type=click.File('w'))
@click.option('-f', '--file-type',
              help="Type of input yaml file",
              type=click.Choice(['top', 'block', 'crossbar']),
              default='top',
              show_default=True)
@click.argument('yaml-file',
                type=click.File('r'))
def main(include_dir, output_file, file_type, yaml_file):
    """Reads in a concise yaml regmap definition and fully
    elaborates it to produce a self-contained, verbose regmap 
    file that can be used by code generators"""
    
    if include_dir is not None:
        YamlIncludeConstructor.add_to_loader_class(loader_class=Loader, base_dir=include_dir)

    regmap = load(yaml_file, Loader=Loader)

    if file_type == "top":
        toplevel = regmap['toplevel']
        elaborate_toplevel(toplevel)
    elif file_type == "block":
        elaborate_block(regmap)
    elif file_type == "crossbar":
        elaborate_crossbar(regmap)
    else:
        pass

    dump(regmap, output_file, Dumper=Dumper)

if __name__ == "__main__":
    main()
