#---------------------------------------------------------------------------------------------------
__all__ = (
    "main",
)

import click
import pathlib
import sys

from regio.regmap.io import *
from regio.regmap.proxy import ClickEnvironment
from .toplevel import *

BAR_IDS = tuple(sorted(BAR_INFO))
PCI_IDS = pci_device_ids()
if not PCI_IDS:
    PCI_IDS = ('none',) # For testing.

THIS_FILE = pathlib.Path(sys.argv[0])
def test_path(pid, bid):
    return THIS_FILE.stem + f'.{pid}.bar{bid}.bin'

IO_TYPES = {
    'dict': lambda spec, pid, bid: DictIO(),
    'list': lambda spec, pid, bid: ListIOForSpec(spec),
    'mmap': lambda spec, pid, bid: FileMmapIOForSpec(spec, test_path(pid, bid)),
    'stream': lambda spec, pid, bid: FileStreamIOForSpec(spec, test_path(pid, bid)),
    'zero': lambda spec, pid, bid: ZeroIO(),
}

#---------------------------------------------------------------------------------------------------
@click.group(
    invoke_without_command=True,
    add_help_option=False,
)
@click.help_option(
    '--help', '-h',
    help='Show this message and exit.',
)
@click.option(
    '-p', '--pci-id', 'pci_ids',
    help='Select PCIe device ID(s) to use for IO (domain:bus:device.function).',
    type=click.Choice(('all',) + PCI_IDS),
    default=(PCI_IDS[0],),
    show_default=True,
    multiple=True,
)
@click.option(
    '-b', '--bar-id', 'bar_ids',
    help='Select which PCIe BAR(s) to use map into memory for IO.',
    type=click.Choice(('all',) + BAR_IDS),
    default=('2',), # TODO: Shouldn't be hardcoded. Get from YAML?
    show_default=True,
    multiple=True,
)
@click.option(
    '-t', '--test-io',
    help='Run in test mode using an alternate IO type independent of hardware.',
    type=click.Choice(tuple(sorted(IO_TYPES))),
)
@ClickEnvironment.main_options
@click.pass_context
def click_main(ctx, pci_ids, bar_ids, test_io, **env_kargs):
    '''
    Perform I/O operations on a PCI device using the {{ top.name }} register mapping.
    Acceptable PCI devices must have vendor ID 0x{{ '{:04x}'.format(top.pci_vendor) }} and device ID 0x{{ '{:04x}'.format(top.pci_device) }}.
    '''

    if 'all' in pci_ids:
        pci_ids = PCI_IDS

    if 'all' in bar_ids:
        bar_ids = BAR_IDS

    io_type = None if test_io is None else IO_TYPES[test_io]

    # Instantiate the selected top-level regmap specifications.
    specs = {}
    for bid in bar_ids:
        specs[bid] = BAR_INFO[bid]['spec_cls']()

    # Build a set of keyword arguments to configure the proxy.
    env = ctx.obj
    proxy_kargs = env.process_options(env_kargs)

    # Create the proxies for each selected PCI device and BAR ID combinations.
    for i, pid in enumerate(pci_ids):
        # Insert a name for the device into the execution environment.
        dev = env.new_variable(f'dev{i}')
        dev.pci_id = pid

        # Create the proxy on the BAR(s).
        for bid in bar_ids:
            io = None if io_type is None else io_type(specs[bid], pid, bid)
            proxy = BAR_INFO[bid]['new_proxy'](pid, specs[bid], io, **proxy_kargs)
            setattr(dev, f'bar{bid}', proxy)

    # Invoked for command line completion, so don't do anything more.
    if env.in_completion:
        return

    # A sub-command wasn't specified, so default to dumping all registers in the environment.
    if ctx.invoked_subcommand is None:
        ctx.invoke(click_main.get_command(ctx, 'dump'))

#---------------------------------------------------------------------------------------------------
def main():
    click_main(obj=ClickEnvironment(click_main))

if __name__ == '__main__':
    main()

