#!/usr/bin/env python3

#---------------------------------------------------------------------------------------------------
# NOTE: This file was autogenerated on {{ now }} by the command:
# {{ cmdline }}
#---------------------------------------------------------------------------------------------------
import click
import pathlib

from regmap.io import *
from regmap.proxy import ClickEnvironment
from {{ top.name_lower }}_toplevel import *

BAR_IDS = tuple(sorted(BAR_INFO))
PCI_IDS = pci_device_ids()
if not PCI_IDS:
    PCI_IDS = ('none',) # For testing.

THIS_FILE = pathlib.Path(__file__)
def test_path(pid, bid):
    return THIS_FILE.stem + f'.{pid}.bar{bid}.bin'

IO_TYPES = {
    'dict': lambda spec, pid, bid: DictIO(),
    'list': lambda spec, pid, bid: ListIOForSpec(spec),
    'mmap': lambda spec, pid, bid: FileMmapIOForSpec(spec, test_path(pid, bid)),
    'stream': lambda spec, pid, bid: FileStreamIOForSpec(spec, test_path(pid, bid)),
    'zero': lambda spec, pid, bid: ZeroIO(),
}

#---------------------------------------------------------------------------------------------------
@click.group(invoke_without_command=True)
@click.option(
    '-p', '--pci-id', 'pci_ids',
    help='Select PCIe device ID(s) to use for IO (domain:bus:device.function)',
    type=click.Choice(('all',) + PCI_IDS),
    default=(PCI_IDS[0],),
    show_default=True,
    multiple=True,
)
@click.option(
    '-b', '--bar-id', 'bar_ids',
    help='Select which PCIe BAR(s) to use map into memory for IO',
    type=click.Choice(('all',) + BAR_IDS),
    default=('2',), # TODO: Shouldn't be hardcoded. Get from YAML?
    show_default=True,
    multiple=True,
)
@click.option(
    '-t', '--test-io',
    help='Run in test mode using an alternate IO type independent of hardware',
    type=click.Choice(tuple(sorted(IO_TYPES))),
    show_default=True,
)
@click.pass_context
def main(ctx, pci_ids, bar_ids, test_io):
    '''
    Perform I/O operations on a PCI device using the {{ top.name }} register mapping.
    Acceptable PCI devices must have vendor ID 0x{{ '{:04x}'.format(top.pci_vendor) }} and device ID 0x{{ '{:04x}'.format(top.pci_device) }}.
    '''

    if 'all' in pci_ids:
        pci_ids = PCI_IDS

    if 'all' in bar_ids:
        bar_ids = BAR_IDS

    io_type = None if test_io is None else IO_TYPES[test_io]

    # Instantiate the selected top-level regmap specifications.
    specs = {}
    for bid in bar_ids:
        specs[bid] = BAR_INFO[bid]['spec_cls']()

    # Create the proxies for each selected PCI device and BAR ID combinations.
    env = ctx.obj
    for i, pid in enumerate(pci_ids):
        # Insert a name for the device into the execution environment.
        dev = env.new_variable(f'dev{i}')
        dev.pci_id = pid

        # Create the proxy on the BAR(s).
        for bid in bar_ids:
            io = None if io_type is None else io_type(specs[bid], pid, bid)
            setattr(dev, f'bar{bid}', BAR_INFO[bid]['new_proxy'](pid, specs[bid], io))

    # A sub-command wasn't specified, so default to dumping all registers in the environment.
    if ctx.invoked_subcommand is None:
        ctx.invoke(main.get_command(ctx, 'dump'))

#---------------------------------------------------------------------------------------------------
if __name__ == '__main__':
    main(obj=ClickEnvironment(main))

