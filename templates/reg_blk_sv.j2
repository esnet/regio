module {{ blk.name_lower }}_reg_blk (
    axi4l_intf.peripheral axil_if,
    {{ blk.name_lower }}_reg_intf.controller reg_blk_if
);

import {{ blk.name_lower }}_reg_pkg::*;

// -------------------------------------------------------------
// Terminate AXI-L interface
// -------------------------------------------------------------

reg_intf reg_if ();

axi4l_reg_peripheral i_axi4l_reg_peripheral (
    .axi4l_if (axil_if),
    .reg_if (reg_if)
);

// -------------------------------------------------------------
// Registers
// -------------------------------------------------------------

{%  for reg in blk.regs: -%}
  {%- if reg.access == "none" %}
    {%- continue %}
  {%- endif %}
// {{ reg.name_upper }} ({{ reg.width }}-bit, {{ reg.access }})
  {%- if reg.access == "ro" %}
reg_ro #(reg_{{ reg.name_lower }}_t, INIT_{{ reg.name_upper }}) {{ reg.name_lower }}_reg (
    .clk (reg_if.clk), .srst (reg_if.srst),
    .upd_en (reg_blk_if.{{ reg.name_lower }}_nxt_v), .upd_data (reg_blk_if.{{ reg.name_lower }}_nxt),
    .rd_data (reg_blk_if.{{ reg.name_lower }})
);
  {%- elif reg.access == "wr_evt" %}
reg_wr_evt #(reg_{{ reg.name_lower }}_t, INIT_{{ reg.name_upper }}) {{ reg.name_lower }}_reg (
    .clk (reg_if.clk), .srst (reg_if.srst),
    .wr (reg_if.wr), .wr_en (reg_if.wr_addr == OFFSET_{{ reg.name_upper }}), .wr_data (reg_if.wr_data[0 +: $bits(reg_{{ reg.name_lower }}_t)]),
    .rd_data (reg_blk_if.{{ reg.name_lower }}),
    .wr_evt (reg_blk_if.{{ reg.name_lower }}_wr_evt)
);
  {%- elif reg.access == "rw" %}
reg_rw #(reg_{{ reg.name_lower }}_t, INIT_{{ reg.name_upper }}) {{ reg.name_lower }}_reg (
    .clk (reg_if.clk), .srst (reg_if.srst),
    .wr (reg_if.wr), .wr_en (reg_if.wr_addr == OFFSET_{{ reg.name_upper }}), .wr_data (reg_if.wr_data[0 +: $bits(reg_{{ reg.name_lower }}_t)]),
    .rd_data (reg_blk_if.{{ reg.name_lower }})
);
  {%- elif reg.access == "rd_evt" %}
reg_rd_evt #(reg_{{ reg.name_lower }}_t, INIT_{{ reg.name_upper }}) {{ reg.name_lower }}_reg (
    .clk (reg_if.clk), .srst (reg_if.srst),
    .rd (reg_if.rd), .rd_en (reg_if.rd_addr == OFFSET_{{ reg.name_upper }}),
    .upd_en (reg_blk_if.{{ reg.name_lower }}_nxt_v), .upd_data (reg_blk_if.{{ reg.name_lower }}_nxt),
    .rd_data (reg_blk_if.{{ reg.name_lower }}),
    .rd_evt (reg_blk_if.{{ reg.name_lower }}_rd_evt)
);
  {%- endif %}
{%- endfor %}

// -------------------------------------------------------------
// Write address decode
// -------------------------------------------------------------
initial begin
    reg_if.wr_ack = 1'b0;
    reg_if.wr_error = 1'b0;
end
always @(posedge reg_if.clk) begin
    if (reg_if.srst) begin
        reg_if.wr_ack <= 1'b0;
        reg_if.wr_error <= 1'b0;
    end else begin
        if (reg_if.wr) begin
            reg_if.wr_ack <= 1'b1;
            reg_if.wr_error <= 1'b1;
            case (reg_if.wr_addr)
{%-  for reg in blk.regs: %}
  {%- if reg.access == "none" %}
    {%- continue %}
  {%- endif %}
                OFFSET_{{ "{:35}".format(reg.name_upper ~ ':') }} reg_if.wr_error <= 1'b0;
{%- endfor %}
            endcase
        end else begin
            reg_if.wr_ack <= 1'b0;
            reg_if.wr_error <= 1'b0;
        end
    end
end

// -------------------------------------------------------------
// Read address decode and data mux
// -------------------------------------------------------------
initial begin
    reg_if.rd_data = 0;
    reg_if.rd_ack = 1'b0;
    reg_if.rd_error = 1'b0;
end
always @(posedge reg_if.clk) begin
    if (reg_if.srst) begin
        reg_if.rd_data <= 0;
        reg_if.rd_ack <= 1'b0;
        reg_if.rd_error <= 1'b0;
    end else begin
        if (reg_if.rd) begin
            reg_if.rd_ack <= 1'b1;
            reg_if.rd_error <= 1'b0;
            case (reg_if.rd_addr)
{%-  for reg in blk.regs: %}
  {%- if reg.access == "none" %}
    {%- continue %}
  {%- endif %}
                OFFSET_{{ "{:35}".format(reg.name_upper ~ ':') }} reg_if.rd_data <= reg_blk_if.{{ reg.name_lower }};
{%- endfor %}
                default: begin
                    reg_if.rd_error <= 1'b1;
                end
            endcase
        end else begin
            reg_if.rd_ack <= 1'b0;
            reg_if.rd_error <= 1'b0;
        end
    end
end

endmodule : {{ blk.name_lower }}_reg_blk
